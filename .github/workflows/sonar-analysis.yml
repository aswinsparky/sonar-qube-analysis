name: SonarQube Analysis Inline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

jobs:
  sonar:
    runs-on: ubuntu-latest
    env:
      SONAR_HOST_URL: "http://13.223.150.126:9000"
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Run SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}

      - name: Install jq and curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Wait for CE Task & Fetch Issues
        run: |
          TASK_FILE=".scannerwork/report-task.txt"
          if [ ! -f "$TASK_FILE" ]; then
            echo "❌ report-task.txt NOT FOUND"
            exit 1
          fi
          CE_TASK_ID=$(grep 'ceTaskId' $TASK_FILE | cut -d '=' -f2)
          COMPONENT_KEY=$(grep -E 'componentKey|projectKey' $TASK_FILE | cut -d '=' -f2)
          STATUS="PENDING"
          ATTEMPTS=0
          while [[ "$STATUS" != "SUCCESS" && $ATTEMPTS -lt 30 ]]; do
            sleep 5
            CE_STATUS=$(curl -s -u "${SONAR_TOKEN}:" "$SONAR_HOST_URL/api/ce/task?id=$CE_TASK_ID")
            STATUS=$(echo "$CE_STATUS" | jq -r '.task.status // empty')
            echo "Sonar CE Task: $STATUS (attempt $ATTEMPTS)"
            ATTEMPTS=$((ATTEMPTS + 1))
          done
          if [ "$STATUS" != "SUCCESS" ]; then
            echo "❌ CE task did NOT finish"
            exit 1
          fi
          curl -s -u "${SONAR_TOKEN}:" \
            "$SONAR_HOST_URL/api/issues/search?componentKeys=$COMPONENT_KEY&ps=500" \
            > sonar_issues.json
          python3 - <<EOF
          import json, os, tempfile
          try:
              with open("sonar_issues.json") as f:
                  data = json.load(f)
              filtered = []
              for iss in data.get("issues", []):
                  comp = iss.get("component", "")
                  path = comp.split(":", 1)[1] if ":" in comp else comp
                  if os.path.exists(path):
                      filtered.append(iss)
              fd, tempf = tempfile.mkstemp()
              with os.fdopen(fd, 'w') as f:
                  json.dump({"issues": filtered}, f)
              with open(tempf) as f:
                  _ = json.load(f)
              os.replace(tempf, "sonar_issues_filtered.json")
              print(f"Wrote {len(filtered)} filtered issues.")
          except Exception as e:
              print("Error filtering/writing issues; writing safe empty file:", e)
              with open("sonar_issues_filtered.json", "w") as f:
                  json.dump({"issues": []}, f)
          EOF
          cp sonar_issues.json sonar_issues_raw.json

      - name: Prepare issue_summary.txt
        run: |
          if python3 -c 'import sys, json; json.load(sys.stdin)' < sonar_issues_filtered.json >/dev/null 2>&1 && jq -e 'has("issues") and (.issues | length > 0)' sonar_issues_filtered.json >/dev/null; then
            jq -r '
              .issues[] |
              "Severity: \(.severity)\nRule: \(.rule)\nFile: \(.component)\nLine: \(.line)\nMessage: \(.message)\n---"
            ' sonar_issues_filtered.json > issue_summary.txt
          else
            echo "No issues found." > issue_summary.txt
          fi

      - name: Fetch SonarQube Metrics
        run: |
          COMPONENT_KEY=$(grep -E 'componentKey|projectKey' .scannerwork/report-task.txt | cut -d '=' -f2)
          curl -s -u "${SONAR_TOKEN}:" \
            "$SONAR_HOST_URL/api/measures/component?component=$COMPONENT_KEY&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,complexity" \
            > sonar_metrics.json

      - name: Prepare sonar_metrics_summary.txt
        run: |
          if jq -e 'has("component") and (.component.measures | length > 0)' sonar_metrics.json >/dev/null; then
            jq -r '.component.measures[] | "\(.metric): \(.value)"' sonar_metrics.json > sonar_metrics_summary.txt
          else
            echo "No metrics found." > sonar_metrics_summary.txt
          fi

      - name: Get changed files and lines in PR
        if: github.event_name == 'pull_request'
        id: diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER=${{ github.event.pull_request.number }}
          echo "PR_NUMBER=$PR_NUMBER"

          # 1) try to get file list via gh (fast)
          if gh pr diff "$PR_NUMBER" --name-only > changed_files.txt 2>/dev/null; then
            sort -u changed_files.txt -o changed_files.txt || true
            echo "Wrote changed_files.txt via 'gh pr diff --name-only'"
          else
            echo "'gh pr diff --name-only' failed; falling back to GH API"
            gh api -X GET "/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}/files" --jq '.[].filename' > changed_files.txt || true
            sort -u changed_files.txt -o changed_files.txt || true
          fi

          # 2) try to get patch; if unavailable, write an empty changed_lines.json
          if gh pr diff "$PR_NUMBER" --patch > pr.diff 2>/dev/null && [ -s pr.diff ]; then
            echo "Patch downloaded to pr.diff; parsing added lines into changed_lines.json"
            python3 - <<'PY'
          import re, json, sys

          def parse_diff(path):
              lines = {}
              curr_file = None
              lineno = None
              hunk_re = re.compile(r'^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@')
              with open(path, 'r', encoding='utf-8', errors='replace') as f:
                  for raw in f:
                      line = raw.rstrip('\n')
                      if line.startswith('+++ b/'):
                          curr_file = line[6:]
                          lines[curr_file] = []
                          lineno = None
                          continue
                      m = hunk_re.match(line)
                      if m:
                          lineno = int(m.group(1))
                          continue
                      if curr_file is not None and lineno is not None:
                          if line.startswith('+') and not line.startswith('+++'):
                              lines[curr_file].append(lineno)
                              lineno += 1
                          else:
                              if not line.startswith('-'):
                                  lineno += 1
              return lines

          if __name__ == '__main__':
              parsed = parse_diff('pr.diff')
              with open('changed_lines.json', 'w') as out:
                  json.dump(parsed, out, indent=2)
              print(f'Parsed changed lines for {len(parsed)} files')
              PY
          else
              echo "Patch unavailable (gh returned non-zero or empty). Writing empty changed_lines.json."
              printf '{}' > changed_lines.json
          fi

      - name: Post SonarQube Inline Review Comments
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const issues = JSON.parse(fs.readFileSync('sonar_issues_filtered.json')).issues;
            const changed = JSON.parse(fs.readFileSync('changed_lines.json'));
            const commit_id = context.payload.pull_request.head.sha;
            let comments = [];
            for (const issue of issues) {
              const comp = issue.component || "";
              const path = comp.includes(':') ? comp.split(':')[1] : comp;
              const line = issue.line || 1;
              if (!changed[path] || !changed[path].length) continue;
              if (!changed[path].includes(line)) continue;
              comments.push({
                path,
                line,
                side: 'RIGHT',
                body: `SonarQube ${issue.severity}: ${issue.message}`
              });
            }
            if (comments.length > 0) {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                commit_id,
                event: "COMMENT",
                comments
              });
            } else {
              console.log("No SonarQube issues to post as line comments.");
            }

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-south-1

      - name: Upload to S3
        run: |
          pip install --user awscli
          aws s3 cp issue_summary.txt s3://${{ secrets.AWS_S3_BUCKET }}/
          aws s3 cp sonar_metrics_summary.txt s3://${{ secrets.AWS_S3_BUCKET }}/
          aws s3 cp sonar_issues_filtered.json s3://${{ secrets.AWS_S3_BUCKET }}/
          aws s3 cp sonar_issues_raw.json s3://${{ secrets.AWS_S3_BUCKET }}/
